"""SyntheticImageSampler class for generating synthetic images from flow fields."""
import logging
from typing import Callable, Tuple

import jax
import jax.numpy as jnp
from jax.experimental import mesh_utils
from jax.experimental.shard_map import shard_map
from jax.sharding import Mesh, PartitionSpec

from src.sym.data_generate import input_check_gen_img_from_flow
from src.utils import logger


class SyntheticImageSampler:
    """Iterator class that generates synthetic images from flow fields.

    This class repeatedly samples flow fields from a FlowFieldScheduler, and for each,
    generates a specified number of synthetic images using JAX random keys.
    The generation is performed by a JAX-compatible synthesis function passed by the user.
    The sampler yields batches of synthetic images, and automatically switches to a new
    flow field after generating a defined number of images from the current one.

    Typical usage involves feeding the resulting batches into a model training loop or
    downstream processing pipeline.
    """

    def __init__(
        self,
        scheduler,
        img_gen_fn: Callable[..., jnp.ndarray],
        images_per_field: int = 1000,
        batch_size: int = 250,
        position_bounds: Tuple[int, int] = (512, 512),
        image_shape: Tuple[int, int] = (256, 256),
        img_offset: Tuple[int, int] = (20, 20),
        num_particles: int = 40000,
        p_hide_img1: float = 0.01,
        p_hide_img2: float = 0.01,
        diameter_range: Tuple[float, float] = (0.1, 1.0),
        intensity_range: Tuple[float, float] = (50, 200),
        rho_range: Tuple[float, float] = (-0.99, 0.99),
        dt: float = 1.0,
        seed: int = 0,
    ):
        """Initializes the SyntheticImageSampler.

        Args:
            scheduler: An instance of FlowFieldScheduler that provides flow fields.
            img_gen_fn: Callable[..., jnp.ndarray]
                JAX-compatible function (flow_field, key, ...) -> batch of images.
            images_per_field: int
                Number of synthetic images to generate per flow field.
            batch_size: int
                Number of synthetic images per batch.
            position_bounds: Tuple[int, int]
                Shape of the big image from which the flow field is sampled.
            image_shape: Tuple[int, int]
                Shape of the synthetic images.
            img_offset: Tuple[int, int]
                Offset for the synthetic images within the big image.
            num_particles: int
                Number of particles to simulate.
            p_hide_img1: float
                Probability of hiding particles in the first image.
            p_hide_img2: float
                Probability of hiding particles in the second image.
            diameter_range: Tuple[float, float]
                Range of diameters for particles.
            intensity_range: Tuple[float, float]
                Range of intensities for particles.
            rho_range: Tuple[float, float]
                Range of correlation coefficients for particles.
            dt: float
                Time step for the simulation.
            seed: int
                Random seed for JAX PRNG.
        """
        # Name of the axis for the device mesh
        shard_keys = "keys"

        # Check how many GPUs are available
        num_devices = len(jax.devices())

        # Setup device mesh
        # We want to shard a key to each device
        # and duplicate the flow field.
        # The idea is that each device will generate a num_images images
        # and then stack it with the images generated by the other GPUs.
        devices = mesh_utils.create_device_mesh((num_devices,))
        mesh = Mesh(devices, axis_names=(shard_keys))

        if not hasattr(scheduler, "__iter__"):
            raise ValueError("scheduler must be an iterable object.")
        if not hasattr(scheduler, "__next__"):
            raise ValueError(
                "scheduler must be an iterable object with __next__ method."
            )
        self.scheduler = scheduler

        if not callable(img_gen_fn):
            raise ValueError("img_gen_fn must be a callable function.")

        if not isinstance(images_per_field, int) or images_per_field <= 0:
            raise ValueError("images_per_field must be a positive integer.")
        self.images_per_field = images_per_field

        if not isinstance(batch_size, int) or batch_size <= 0:
            raise ValueError("batch_size must be a positive integer.")
        # Make sure the batch size is divisible by the number of devices
        if batch_size % num_devices != 0:
            batch_size = (batch_size // num_devices + 1) * num_devices
            logger.warning(
                f"Batch size was not divisible by the number of devices. "
                f"Setting batch_size to {batch_size}."
            )
        self.batch_size = batch_size

        if len(position_bounds) != 2 or not all(
            isinstance(s, int) and s > 0 for s in position_bounds
        ):
            raise ValueError(
                "position_bounds must be a tuple of two positive integers."
            )
        self.position_bounds = position_bounds

        if len(image_shape) != 2 or not all(
            isinstance(s, int) and s > 0 for s in image_shape
        ):
            raise ValueError("image_shape must be a tuple of two positive integers.")
        self.image_shape = image_shape

        if len(img_offset) != 2 or not all(
            isinstance(s, int) and s >= 0 for s in img_offset
        ):
            raise ValueError("img_offset must be a tuple of two non-negative integers.")
        self.img_offset = img_offset

        if not isinstance(num_particles, int) or num_particles <= 0:
            raise ValueError("num_particles must be a positive integer.")
        self.num_particles = num_particles

        if not (0 <= p_hide_img1 <= 1):
            raise ValueError("p_hide_img1 must be between 0 and 1.")
        self.p_hide_img1 = p_hide_img1

        if not (0 <= p_hide_img2 <= 1):
            raise ValueError("p_hide_img2 must be between 0 and 1.")
        self.p_hide_img2 = p_hide_img2

        if len(diameter_range) != 2 or not all(
            isinstance(d, (int, float)) and d > 0 for d in diameter_range
        ):
            raise ValueError("diameter_range must be a tuple of two positive floats.")
        self.diameter_range = diameter_range

        if len(intensity_range) != 2 or not all(
            isinstance(i, (int, float)) and i >= 0 for i in intensity_range
        ):
            raise ValueError(
                "intensity_range must be a tuple of two non-negative floats."
            )
        self.intensity_range = intensity_range

        if len(rho_range) != 2 or not all(
            isinstance(r, (int, float)) and -1 <= r <= 1 for r in rho_range
        ):
            raise ValueError(
                "rho_range must be a tuple of two floats between -1 and 1."
            )
        self.rho_range = rho_range

        if not isinstance(dt, (int, float)):
            raise ValueError("dt must be a scalar (int or float)")
        self.dt = dt

        if not isinstance(seed, int) or seed < 0:
            raise ValueError("seed must be a positive integer.")
        self.seed = seed

        if images_per_field % batch_size != 0:
            logger.warning(
                f"images_per_field was not divisible by the batch size. "
                f"Generating an extra "
                f"{((images_per_field // batch_size + 1)*batch_size - images_per_field)}"
                f" per flow field."
            )

        if not logger.isEnabledFor(logging.DEBUG):
            self.img_gen_fn_jit = jax.jit(
                shard_map(
                    lambda key, flow: img_gen_fn(
                        key=key,
                        flow_field=flow,
                        position_bounds=self.position_bounds,
                        image_shape=self.image_shape,
                        img_offset=self.img_offset,
                        num_images=self.batch_size // num_devices,
                        num_particles=self.num_particles,
                        p_hide_img1=self.p_hide_img1,
                        p_hide_img2=self.p_hide_img2,
                        diameter_range=self.diameter_range,
                        intensity_range=self.intensity_range,
                        rho_range=self.rho_range,
                        dt=self.dt,
                    ),
                    mesh=mesh,
                    in_specs=(PartitionSpec(shard_keys), PartitionSpec()),
                    out_specs=(PartitionSpec(shard_keys), PartitionSpec(shard_keys)),
                )
            )
        else:
            self.img_gen_fn_jit = lambda key, flow: img_gen_fn(
                key=key,
                flow_field=flow,
                position_bounds=self.position_bounds,
                image_shape=self.image_shape,
                img_offset=self.img_offset,
                num_images=self.batch_size // num_devices,
                num_particles=self.num_particles,
                p_hide_img1=self.p_hide_img1,
                p_hide_img2=self.p_hide_img2,
                diameter_range=self.diameter_range,
                intensity_range=self.intensity_range,
                rho_range=self.rho_range,
                dt=self.dt,
            )

        logger.debug("Input arguments of SyntheticImageSampler are valid.")
        logger.debug(f"Image shape: {self.image_shape}")
        logger.debug(f"Big image shape: {self.position_bounds}")
        logger.debug(f"Image offset: {self.img_offset}")
        logger.debug(f"Number of particles: {self.num_particles}")
        logger.debug(f"Images per field: {self.images_per_field}")
        logger.debug(f"Batch size: {self.batch_size}")
        logger.debug(f"Diameter range: {self.diameter_range}")
        logger.debug(f"Intensity range: {self.intensity_range}")
        logger.debug(f"Rho range: {self.rho_range}")
        logger.debug(f"dt: {self.dt}")
        logger.debug(f"p_hide_img1: {self.p_hide_img1}")
        logger.debug(f"p_hide_img2: {self.p_hide_img2}")
        logger.debug(f"Seed: {self.seed}")
        logger.debug(f"Flow field scheduler: {self.scheduler}")
        logger.debug(f"Image generation function: {img_gen_fn}")

        self._rng = jax.random.PRNGKey(seed)
        self._current_flow = None
        self._images_generated = 0

    def __iter__(self):
        """Returns the iterator instance itself."""
        return self

    def reset(self):
        """Resets the state variables to their initial values."""
        self._rng = jax.random.PRNGKey(self.seed)
        self._current_flow = None
        self._images_generated = 0

    def __next__(self):
        """Generates the next batch of synthetic images.

        Raises:
            StopIteration: Never raised by default, it is thrown by scheduler.

        Returns:
            jnp.ndarray: A batch of synthetic images generated on GPU.
        """
        # Check if we need to initialize or switch to a new flow field
        if (
            self._current_flow is None
            or self._images_generated >= self.images_per_field
        ):
            self._current_flow = jnp.array(next(self.scheduler))
            self._images_generated = 0

        # Generate a new random key for image generation
        self._rng, subkey = jax.random.split(self._rng)
        keys = jax.random.split(subkey, jax.device_count())

        logger.debug(f"Current flow field shape: {self._current_flow.shape}")
        logger.debug(f"Current flow field type: {type(self._current_flow)}")
        logger.debug(f"Current random key: {keys}")

        if logger.isEnabledFor(logging.DEBUG):
            input_check_gen_img_from_flow(
                key=keys[0],
                flow_field=self._current_flow,
                position_bounds=self.position_bounds,
                image_shape=self.image_shape,
                img_offset=self.img_offset,
                num_images=self.batch_size,
                num_particles=self.num_particles,
                p_hide_img1=self.p_hide_img1,
                p_hide_img2=self.p_hide_img2,
                diameter_range=self.diameter_range,
                intensity_range=self.intensity_range,
                rho_range=self.rho_range,
                dt=self.dt,
            )

        # Generate a new batch of images using the current flow field
        imgs1, imgs2 = self.img_gen_fn_jit(keys, self._current_flow)

        logger.debug(f"Generated images shape: {imgs1.shape}, {imgs2.shape}")

        assert (
            imgs1.shape[0] == self.batch_size
        ), f"Expected {self.batch_size} images but got {imgs1.shape[0]}"
        assert (
            imgs2.shape[0] == self.batch_size
        ), f"Expected {self.batch_size} images but got {imgs2.shape[0]}"

        logger.info(f"Generated {self.batch_size} couples of images")
        self._images_generated += self.batch_size
        logger.debug(f"Total images generated so far: {self._images_generated}")
        return imgs1, imgs2, self._current_flow
